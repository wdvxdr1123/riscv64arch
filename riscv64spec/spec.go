// Copyright 2023 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"fmt"
	gofmt "go/format"
	"io"
	"log"
	"net/http"
	"sort"
	"strings"
	"text/template"
)

type Inst struct {
	name      string
	Extension string
	Mask      uint32
	Match     uint32
	Args      []string
}

func (i *Inst) GoName() string {
	n := strings.ReplaceAll(i.name, ".", "")
	return strings.ToUpper(n)
}

func (i *Inst) GNUName() string {
	return strings.ToUpper(i.name)
}

func (i *Inst) AddArg(arg string) {
	switch arg {
	case "aq", "rl", "imm12hi", "bimm12hi", "fm":
		return // ignore
	case "imm12lo", "bimm12lo":
		arg = strings.Replace(arg, "lo", "hilo", 1)
	case "rs1", "rd":
		if i.name == "fence" {
			// rs1 and rd field in fence instruction are unused.
			return
		}
	}
	i.Args = append(i.Args, arg)
}

type generator struct {
	Inst []Inst
}

func (g *generator) addExtension(ext string) {
	s, err := fetch(ext)
	if err != nil {
		panic(err)
	}
	for _, l := range strings.Split(s, "\n") {
		l = strings.TrimSpace(l)
		if l == "" || l[0] == '#' || l[0] == '$' {
			// ignore blank lines, comments, imports and pseudo instructions
			continue
		}
		g.addLine(l)
	}
}

func (g *generator) addLine(src string) {
	var inst Inst
	inst.Mask = uint32(0)
	for i, field := range strings.Fields(src) {
		// instruction name
		if i == 0 {
			inst.name = field
			continue
		}
		// instruction variable argument
		if !strings.Contains(field, "=") {
			inst.AddArg(field)
			continue
		}
		var start, end, value int
		if strings.Contains(field, "..") {
			// fixed range pattern:  <start>..<end>=value
			fmt.Sscanf(field, "%v..%v=%v", &start, &end, &value)
		} else {
			// single fixed pattern: e.g. 6=1
			fmt.Sscanf(field, "%v=%v", &start, &value)
			end = start
		}
		inst.Match |= uint32(value << end)
		for j := start; j >= end; j-- {
			inst.Mask |= uint32(1 << j)
		}
		continue
	}
	g.Inst = append(g.Inst, inst)
}

func fetch(ext string) (string, error) {
	get, err := http.Get("https://raw.githubusercontent.com/riscv/riscv-opcodes/master/" + ext)
	if err != nil {
		return "", err
	}
	defer get.Body.Close()
	body, err := io.ReadAll(get.Body)
	if err != nil {
		return "", err
	}
	return string(body), nil
}

func main() {
	var g generator
	exts := []string{
		"rv_i", "rv_m", "rv_a", // "rv_f", "rv_d",
		"rv64_i", "rv64_m", "rv64_a", // "rv64_f", "rv64_d",
	}
	for _, ext := range exts {
		g.addExtension(ext)
	}
	sort.Slice(g.Inst, func(i, j int) bool {
		return g.Inst[i].name < g.Inst[j].name
	})

	tmpl, _ := template.New("").Funcs(template.FuncMap{
		"hex":        hex,
		"formatArgs": formatArgs,
	}).Parse(genTemplate)

	var buf bytes.Buffer
	tmpl.Execute(&buf, g.Inst)
	out, err := gofmt.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("gofmt error: %v", err)
	}
	fmt.Printf("%s", out)
}

func hex(i uint32) string {
	return fmt.Sprintf("0x%x", i)
}

func formatArgs(args []string) string {
	var sb strings.Builder
	sb.WriteString("instArgs{")
	for i, arg := range args {
		if i != 0 {
			sb.WriteString(",")
		}
		sb.WriteString("arg_" + arg)
	}
	sb.WriteString("}")
	return sb.String()
}

const genTemplate = `// Code generated by riscvspec. DO NOT EDIT.

// Copyright 2023 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package riscv64asm

const (
	_ Op = iota
{{range .}}	{{.GoName}}
{{end}})

var opstr = [...]string{
{{range .}}	{{.GoName}}: "{{.GNUName}}",
{{end}}}

var instFormats = [...]instFormat{
{{range .}}	{{"{"}} {{.GoName}}, {{hex .Mask}}, {{hex .Match}}, {{formatArgs .Args}}{{"}"}},
{{end}}}
`
